<html>
<head>
<meta charset="UTF-8">
<title>2048</title>
<style>
  #table { border-collapse: collapse; user-select: none; }
  #table td {
    border: 10px solid #bbada0; width: 116px; height: 128px;
    font-size: 50px; font-weight: bold; text-align: center;
  }
  #score { user-select: none; } /*복사 금지*/
  .color-2 { background-color: #eee4da; color: #776e65;}
  .color-4 { background-color: #eee1c9; color: #776e65;}
  .color-8 { background-color: #f3b27a; color: 'white';}
  .color-16 { background-color: #f69664; color: 'white';}
  .color-32 { background-color: #f77c5f; color: 'white';}
  .color-64 { background-color: #f75f3b; color: 'white';}
  .color-128 { background-color: #edd073; color: #776e65;}
  .color-256 { background-color: #edcc62; color: #776e65;}
  .color-512 { background-color: #edc950; color: #776e65;}
  .color-1024 { background-color: #edc53f; color: #776e65;}
  .color-2048 { background-color: #edc22e; color: #776e65;}
</style>
</head>
<body>
<table id="table"></table>
<button id = "button">되돌리기</button>
<div id="score">0</div>
<script>
  const $table = document.getElementById('table'); //태그를 아이디로 선택
  const $score = document.getElementById('score');
  const $button = document.getElementById('button');
  let data = []; //4X4 테이블
  const traceData = []; //data 저장소

  //$table > $fragment > $tr > $td
  //fragment 쓰는 이유는 메모리에만 저장되는 가상변수이기 때문
  
  function startGame(){
    const $fragment = document.createDocumentFragment(); //성능때문에 사용
    [1,2,3,4].forEach(function() {
      const rowData = []; //2차원배열로 만들기위해 생성함
      data.push(rowData);
      const $tr = document.createElement('tr');
      [1,2,3,4].forEach(() =>{
        rowData.push(0);
        const $td = document.createElement('td');
        $tr.appendChild($td);
      });
      $fragment.appendChild($tr);
    });
    $table.appendChild($fragment); // 한번에 테이블로 append함
    put2ToRandomCell(); //빈칸에 2 넣기 (데이터)
    draw(); // 빈칸에 2 넣기 (화면)
  }

  function put2ToRandomCell(){
    const emptyCells = []; // [[i1, j1], [i2, j2], [i3, j3]]
    //i와 j는 각각 몇번 째 줄, 칸인지 알 수 있음
    data.forEach(function (rowData, i) {
      rowData.forEach(function (cellData, j) {
        if (!cellData) {//처음에는 모두 0을 대입한 상황이라 전부 해당됨
          emptyCells.push([i, j]);
        }
      });
    });
    // randomCell === [i, j]
    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
    data[randomCell[0]][randomCell[1]] = 2;
  }

  function draw() {
    data.forEach((rowData, i) => {
      rowData.forEach((cellData, j) => {
        const $target = $table.children[i].children[j]; //$table의 children은 tr , tr의 children은 td
        if (cellData > 0) {
          $target.textContent = cellData;
          $target.className = 'color-' + cellData;
        } else {
          $target.textContent = '';
          $target.className = '';
        }
      });
    });
  }
  // data = [
  //   [32, 2, 4, 2],
  //   [64, 4, 8, 4],
  //   [2, 1024, 1024, 32],
  //   [32, 16, 64, 4],
  // ];
  // draw();
  function moveCells(direction) {
    traceData.push({
      table : JSON.parse(JSON.stringify(data)), //참조관계를 끊어줘야함!(중요) 그냥 data라고 하면 안됨
      score: $score.textContent,
    });
    switch (direction) {
      case 'left': {
        const newData = [[], [], [], []]; //임시 저장
        data.forEach((rowData, i) => {//행에 대해
          rowData.forEach((cellData, j) => {
            if (cellData) { // newData = [2, 2, 4] //cellDate가 있을 때
              const currentRow = newData[i] // i는 0일때
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === cellData) { // 이전 값과 지금 값이 같으면 2,2
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2; //한 번에 계산안되게 하기 위해
              } else {
                newData[i].push(cellData);  //빈칸 제외하고 왼쪽칸으로 넣은거
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((rowData, i) => {
          [1, 2, 3, 4].forEach((cellData, j) => {
            data[i][j] = Math.abs(newData[i][j]) || 0; //원본데이터 다시 수정한거
          });
        });
        break;
      }
      case 'right': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (rowData[3 - j]) {
              const currentRow = newData[i]
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === rowData[3 - j]) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[i].push(rowData[3 - j]);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((rowData, i) => {
          [1, 2, 3, 4].forEach((cellData, j) => {
            data[i][3 - j] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
      case 'up': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (cellData) {
              const currentRow = newData[j]
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === cellData) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[j].push(cellData);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((cellData, i) => {
          [1, 2, 3, 4].forEach((rowData, j) => {
            data[j][i] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
      case 'down': {
        const newData = [[], [], [], []];
        data.forEach((rowData, i) => {
          rowData.forEach((cellData, j) => {
            if (data[3 - i][j]) {
              const currentRow = newData[j];
              const prevData = currentRow[currentRow.length - 1];
              if (prevData === data[3 - i][j]) {
                const score = parseInt($score.textContent);
                $score.textContent = score + currentRow[currentRow.length - 1] * 2;
                currentRow[currentRow.length - 1] *= -2;
              } else {
                newData[j].push(data[3 - i][j]);
              }
            }
          });
        });
        console.log(newData);
        [1, 2, 3, 4].forEach((cellData, i) => {
          [1, 2, 3, 4].forEach((rowData, j) => {
            data[3 - j][i] = Math.abs(newData[i][j]) || 0;
          });
        });
        break;
      }
    }
    if (data.flat().includes(2048)) { //data에 2048들어있으면 승리
      draw();
      setTimeout(() => {
        alert('축하합니다. 2048을 만들었습니다!');  
      }, 0);
    } else if (!data.flat().includes(0)) { // 빈 칸이 없으면 패배
      alert(`패배했습니다... ${$score.textContent}점`);
    } else {
      put2ToRandomCell();
      draw();
    }
  }
  window.addEventListener('keyup', (event) => {
    //키보드 코드
    if (event.key === 'ArrowUp') {
      moveCells('up');
    } else if (event.key === 'ArrowDown') {
      moveCells('down');
    } else if (event.key === 'ArrowLeft') {
      moveCells('left');
    } else if (event.key === 'ArrowRight') {
      moveCells('right');
    }
  });

  let startCoord;
  window.addEventListener('mousedown', (event) => {
    startCoord = [event.clientX, event.clientY]; 
    //마우스 누를 때 startCoord에다가 처음 누른 좌표를 기록
  });
  window.addEventListener('mouseup', (event) => {
    //마우스 뗄 때 endCoord에 좌표 기록함
    const endCoord = [event.clientX, event.clientY];
    const diffX = endCoord[0] - startCoord[0];
    const diffY = endCoord[1] - startCoord[1];
    if (diffX < 0 && Math.abs(diffX) > Math.abs(diffY)) {
      moveCells('left');
    } else if (diffX > 0 && Math.abs(diffX) > Math.abs(diffY)) {
      moveCells('right');
    } else if (diffY > 0 && Math.abs(diffX) <= Math.abs(diffY)) {
      moveCells('down');
    } else if (diffY < 0 && Math.abs(diffX) <= Math.abs(diffY)) {
      moveCells('up');
    }
  });

  const clickButton = ()=> {
    const prevData = traceData.pop();
    if (!prevData) return;
    $score.textContent = prevData.score;
    data = prevData.table;
    draw(); //빼먹으면 안됨
  }

  $button.addEventListener('click', clickButton);
  startGame();
</script>
</body>
</html>